"""This type stub file was generated by pyright.
"""

from collections.abc import AsyncIterator, Callable, Iterator, Mapping, Sequence
from functools import cached_property
from typing import (
    Any,
)

from langchain_core.runnables import (
    Runnable,
    RunnableConfig,
    RunnablePassthrough,
    RunnableSerializable,
)
from langchain_core.runnables.base import Input, Other
from langchain_core.runnables.utils import ConfigurableFieldSpec
from langgraph.pregel.retry import RetryPolicy
from langgraph.utils.runnable import RunnableCallable

type READ_TYPE = Callable[[str | Sequence[str], bool], Any | dict[str, Any]]

class ChannelRead(RunnableCallable):
    """Implements the logic for reading state from CONFIG_KEY_READ.
    Usable both as a runnable as well as a static method to call imperatively.
    """

    channel: str | list[str]
    fresh: bool = ...
    mapper: Callable[[Any], Any] | None = ...
    @property
    def config_specs(self) -> list[ConfigurableFieldSpec]: ...
    def __init__(
        self,
        channel: str | list[str],
        *,
        fresh: bool = ...,
        mapper: Callable[[Any], Any] | None = ...,
        tags: list[str] | None = ...,
    ) -> None: ...
    def get_name(
        self, suffix: str | None = ..., *, name: str | None = ...
    ) -> str: ...
    @staticmethod
    def do_read(
        config: RunnableConfig,
        *,
        select: str | list[str],
        fresh: bool = ...,
        mapper: Callable[[Any], Any] | None = ...,
    ) -> Any: ...

DEFAULT_BOUND: RunnablePassthrough = ...

class PregelNode(Runnable):
    """A node in a Pregel graph. This won't be invoked as a runnable by the graph
    itself, but instead acts as a container for the components necessary to make
    a PregelExecutableTask for a node.
    """

    channels: list[str] | Mapping[str, str]
    triggers: list[str]
    mapper: Callable[[Any], Any] | None
    writers: list[Runnable]
    bound: Runnable[Any, Any]
    retry_policy: RetryPolicy | None
    tags: Sequence[str] | None
    metadata: Mapping[str, Any] | None
    def __init__(
        self,
        *,
        channels: list[str] | Mapping[str, str],
        triggers: Sequence[str],
        mapper: Callable[[Any], Any] | None = ...,
        writers: list[Runnable] | None = ...,
        tags: list[str] | None = ...,
        metadata: Mapping[str, Any] | None = ...,
        bound: Runnable[Any, Any] | None = ...,
        retry_policy: RetryPolicy | None = ...,
    ) -> None: ...
    def copy(self, update: dict[str, Any]) -> PregelNode: ...
    @cached_property
    def flat_writers(self) -> list[Runnable]:
        """Get writers with optimizations applied. Dedupes consecutive ChannelWrites."""

    @cached_property
    def node(self) -> Runnable[Any, Any] | None:
        """Get a runnable that combines `bound` and `writers`."""

    def join(self, channels: Sequence[str]) -> PregelNode: ...
    def __or__(
        self,
        other: Runnable[Any, Other] | Callable[[Any], Other] | Mapping[str, Runnable[Any, Other] | Callable[[Any], Other]],
    ) -> PregelNode: ...
    def pipe(
        self,
        *others: Runnable[Any, Other] | Callable[[Any], Other],
        name: str | None = ...,
    ) -> RunnableSerializable[Any, Other]: ...
    def __ror__(
        self,
        other: Runnable[Other, Any] | Callable[[Any], Other] | Mapping[str, Runnable[Other, Any] | Callable[[Other], Any]],
    ) -> RunnableSerializable: ...
    def invoke(
        self,
        input: Input,
        config: RunnableConfig | None = ...,
        **kwargs: Any | None,
    ) -> Any: ...
    async def ainvoke(
        self,
        input: Input,
        config: RunnableConfig | None = ...,
        **kwargs: Any | None,
    ) -> Any: ...
    def stream(
        self,
        input: Input,
        config: RunnableConfig | None = ...,
        **kwargs: Any | None,
    ) -> Iterator[Any]: ...
    async def astream(
        self,
        input: Input,
        config: RunnableConfig | None = ...,
        **kwargs: Any | None,
    ) -> AsyncIterator[Any]: ...
